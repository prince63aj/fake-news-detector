import pandas as pd
import numpy as np
import re
import string
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Optional: Use smaller sample for faster testing (set to False for full run)
USE_SAMPLE = False

# Load datasets
df_fake = pd.read_csv("dataset/Fake.csv")
df_true = pd.read_csv("dataset/True.csv")

# Assign class labels
df_fake["class"] = 0
df_true["class"] = 1

# Reserve 10 rows for manual testing
df_fake_manual_testing = df_fake.tail(10)
df_true_manual_testing = df_true.tail(10)

df_fake = df_fake.iloc[:-10]
df_true = df_true.iloc[:-10]

# Save manual testing file
df_manual_testing = pd.concat([df_fake_manual_testing, df_true_manual_testing], axis=0)
df_manual_testing.to_csv("dataset/manual_testing.csv", index=False)

# Merge datasets
df_merge = pd.concat([df_fake, df_true], axis=0)
df = df_merge.drop(["title", "subject", "date"], axis=1)

# Shuffle and reset index
df = df.sample(frac=1).reset_index(drop=True)

# Text cleaning function
def wordopt(text):
    text = text.lower()
    text = re.sub(r'\[.*?\]', '', text)
    text = re.sub(r'\W', ' ', text)
    text = re.sub(r'https?://\S+|www\.\S+', '', text)
    text = re.sub(r'<.*?>+', '', text)
    text = re.sub(r'[%s]' % re.escape(string.punctuation), '', text)
    text = re.sub(r'\n', '', text)
    text = re.sub(r'\w*\d\w*', '', text)
    return text

df["text"] = df["text"].apply(wordopt)

# Use sample for faster development
if USE_SAMPLE:
    df = df.sample(n=5000)

# Features and labels
x = df["text"]
y = df["class"]

# Train-test split
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25, random_state=42)

# Vectorization
from sklearn.feature_extraction.text import TfidfVectorizer
vectorization = TfidfVectorizer(max_features=5000, stop_words='english')
xv_train = vectorization.fit_transform(x_train)
xv_test = vectorization.transform(x_test)

# Logistic Regression
from sklearn.linear_model import LogisticRegression
LR = LogisticRegression()
LR.fit(xv_train, y_train)
pred_lr = LR.predict(xv_test)
# print("Logistic Regression Accuracy:", accuracy_score(y_test, pred_lr))
# print("Classification Report (Logistic Regression):\n", classification_report(y_test, pred_lr))

# Decision Tree
from sklearn.tree import DecisionTreeClassifier
DT = DecisionTreeClassifier()
DT.fit(xv_train, y_train)
pred_dt = DT.predict(xv_test)
# print("Decision Tree Accuracy:", accuracy_score(y_test, pred_dt))
# print("Classification Report (Decision Tree):\n", classification_report(y_test, pred_dt))

# Gradient Boosting
from sklearn.ensemble import GradientBoostingClassifier
GBC = GradientBoostingClassifier(n_estimators=50, random_state=0)
GBC.fit(xv_train, y_train)
pred_gbc = GBC.predict(xv_test)
# print("Gradient Boosting Accuracy:", accuracy_score(y_test, pred_gbc))
# print("Classification Report (Gradient Boosting):\n", classification_report(y_test, pred_gbc))


from sklearn.ensemble import RandomForestClassifier
RFC = RandomForestClassifier(n_estimators=50,random_state=0)
RFC.fit(xv_train, y_train)
pred_rfc = RFC.predict(xv_test)
print("Random Forest Accuracy:", RFC.score(xv_test, y_test))
print("Classification Report (Random Forest):\n", classification_report(y_test, pred_rfc))


def output_label(n):
    return "Fake News" if n == 0 else "Not A Fake News"

def manual_testing(news):
    # Convert to DataFrame
    test_df = pd.DataFrame({"text": [news]})

    # Preprocess
    test_df["text"] = test_df["text"].apply(wordopt)

    # Vectorize
    test_vector = vectorization.transform(test_df["text"])

    # Predict from each model
    predictions = {
        "Logistic Regression": output_label(LR.predict(test_vector)[0]),
        "Decision Tree": output_label(DT.predict(test_vector)[0]),
        "Gradient Boosting": output_label(GBC.predict(test_vector)[0]),
        "Random Forest": output_label(RFC.predict(test_vector)[0]),
    }

    # Print predictions
    print("\n--- Model Predictions ---")
    for model, result in predictions.items():
        print(f"{model}: {result}")

# Run
if __name__ == "__main__":
    news_input = input("Enter news text:\n")
    manual_testing(news_input)


